program flashmarketsam2.aleo {
    const OPEN: u8 = 0u8;
    const CLOSED: u8 = 1u8;
    const RESOLVED: u8 = 2u8;
    const VOID: u8 = 3u8;
    const SINGLETON_KEY: u8 = 0u8;
    const FEE_BPS: u64 = 0u64;
    const BPS_DENOM: u64 = 10000u64;

    record Bet {
        owner: address,
        market_id: u64,
        side_yes: bool,
        amount: u64,
        claimed: bool
    }

    struct PositionKey {
        market_id: u64,
        bettor: address,
        side_yes: bool,
    }

    mapping admin: u8 => address;
    mapping active_market_id: u8 => u64;
    mapping market_status: u64 => u8;
    mapping start_ts: u64 => u64;
    mapping end_ts: u64 => u64;
    mapping close_ts: u64 => u64;
    mapping start_price_e8: u64 => u64;
    mapping end_price_e8: u64 => u64;
    mapping outcome_yes: u64 => bool;
    mapping yes_total_public: u64 => u64;
    mapping no_total_public: u64 => u64;
    mapping sentiment_bps: u64 => i32;
    mapping position_amount: PositionKey => u64;
    mapping position_claimed: PositionKey => bool;

    @admin(address="aleo1774u9274sm7h95nr4dwpsgn2l27amjldntkustcav2xf0jx6evrqxmtzdt")
    async constructor() {
        // Constructor policy is generated by the Leo compiler.
    }

    async transition initialize_admin(admin_address: address) -> Future {
        return async {
            assert_eq(admin.contains(SINGLETON_KEY), false);
            admin.set(SINGLETON_KEY, admin_address);
        };
    }

    async transition create_round(
        market_id: u64,
        start_time: u64,
        end_time: u64,
        close_time: u64,
        start_price: u64
    ) -> Future {
        let caller: address = self.caller;
        return create_round_finalize(caller, market_id, start_time, end_time, close_time, start_price);
    }

    async function create_round_finalize(
        public caller: address,
        market_id: u64,
        start_time: u64,
        end_time: u64,
        close_time: u64,
        start_price: u64
    ) {
            let admin_address: address = admin.get(SINGLETON_KEY);
            assert_eq(caller, admin_address);

            if active_market_id.contains(SINGLETON_KEY) {
                let current_market: u64 = active_market_id.get(SINGLETON_KEY);
                let current_status: u8 = market_status.get_or_use(current_market, VOID);
                assert_eq(current_status == OPEN || current_status == CLOSED, false);
            }

            assert_eq(start_time < close_time, true);
            assert_eq(close_time < end_time, true);

            active_market_id.set(SINGLETON_KEY, market_id);
            market_status.set(market_id, OPEN);
            start_ts.set(market_id, start_time);
            end_ts.set(market_id, end_time);
            close_ts.set(market_id, close_time);
            start_price_e8.set(market_id, start_price);
            yes_total_public.set(market_id, 0u64);
            no_total_public.set(market_id, 0u64);
    }

    async transition place_bet(market_id: u64, side_yes: bool, amount: u64) -> Future {
        assert_eq(amount >= 1u64, true);
        let caller: address = self.caller;
        return place_bet_finalize(caller, market_id, side_yes, amount);
    }

    async function place_bet_finalize(
        public caller: address,
        market_id: u64,
        side_yes: bool,
        amount: u64
    ) {
        let status: u8 = market_status.get_or_use(market_id, VOID);
        assert_eq(status, OPEN);
        let active_id: u64 = active_market_id.get(SINGLETON_KEY);
        assert_eq(active_id, market_id);
        let position: PositionKey = PositionKey {
            market_id,
            bettor: caller,
            side_yes
        };
        let prior_position_amount: u64 = position_amount.get_or_use(position, 0u64);
        position_amount.set(position, prior_position_amount + amount);
        position_claimed.set(position, false);

        if side_yes {
            let yes_before: u64 = yes_total_public.get_or_use(market_id, 0u64);
            yes_total_public.set(market_id, yes_before + amount);
        } else {
            let no_before: u64 = no_total_public.get_or_use(market_id, 0u64);
            no_total_public.set(market_id, no_before + amount);
        }
    }

    async transition close_round(market_id: u64) -> Future {
        let caller: address = self.caller;
        return close_round_finalize(caller, market_id);
    }

    async function close_round_finalize(public caller: address, market_id: u64) {
            let admin_address: address = admin.get(SINGLETON_KEY);
            assert_eq(caller, admin_address);
            assert_eq(market_status.get_or_use(market_id, VOID), OPEN);
            market_status.set(market_id, CLOSED);
    }

    async transition resolve_round(market_id: u64, end_price: u64) -> Future {
        let caller: address = self.caller;
        return resolve_round_finalize(caller, market_id, end_price);
    }

    async function resolve_round_finalize(
        public caller: address,
        market_id: u64,
        end_price: u64
    ) {
            let admin_address: address = admin.get(SINGLETON_KEY);
            assert_eq(caller, admin_address);
            assert_eq(market_status.get_or_use(market_id, VOID), CLOSED);

            let start_price: u64 = start_price_e8.get(market_id);
            let yes_total: u64 = yes_total_public.get_or_use(market_id, 0u64);
            let no_total: u64 = no_total_public.get_or_use(market_id, 0u64);
            let yes_wins: bool = end_price > start_price;
            let pool_sum: u64 = yes_total + no_total;
            let safe_pool_sum: u64 = pool_sum == 0u64 ? 1u64 : pool_sum;
            let sentiment: i32 = pool_sum == 0u64
                ? 0i32
                : ((yes_total as i128 - no_total as i128) * 10000i128 / safe_pool_sum as i128) as i32;

            end_price_e8.set(market_id, end_price);
            outcome_yes.set(market_id, yes_wins);
            sentiment_bps.set(market_id, sentiment);
            market_status.set(market_id, RESOLVED);
    }

    async transition void_round(market_id: u64) -> Future {
        let caller: address = self.caller;
        return void_round_finalize(caller, market_id);
    }

    async function void_round_finalize(public caller: address, market_id: u64) {
            let admin_address: address = admin.get(SINGLETON_KEY);
            assert_eq(caller, admin_address);
            let status: u8 = market_status.get_or_use(market_id, VOID);
            assert_eq(status == RESOLVED, false);
            market_status.set(market_id, VOID);
    }

    async transition claim_reward(
        market_id: u64,
        side_yes: bool,
        reported_user_amount: u64,
        reported_yes_total: u64,
        reported_no_total: u64,
        reported_outcome_yes: bool,
        reported_status: u8
    ) -> (u64, Future) {
        assert_eq(reported_user_amount > 0u64, true);

        let is_void: bool = reported_status == VOID;
        let winning_total: u64 = reported_outcome_yes ? reported_yes_total : reported_no_total;
        let pool_total: u64 = reported_yes_total + reported_no_total;
        let fee: u64 = (pool_total * FEE_BPS) / BPS_DENOM;
        let distributable_pool: u64 = pool_total - fee;
        let is_winner: bool = side_yes == reported_outcome_yes;
        let payout: u64 = is_void
            ? reported_user_amount
            : (is_winner && winning_total > 0u64)
                ? (reported_user_amount * distributable_pool) / winning_total
                : 0u64;

        let caller: address = self.caller;
        return (
            payout,
            claim_reward_finalize(
                caller,
                market_id,
                side_yes,
                reported_user_amount,
                reported_yes_total,
                reported_no_total,
                reported_outcome_yes,
                reported_status
            )
        );
    }

    async function claim_reward_finalize(
        public caller: address,
        market_id: u64,
        side_yes: bool,
        reported_user_amount: u64,
        reported_yes_total: u64,
        reported_no_total: u64,
        reported_outcome_yes: bool,
        reported_status: u8
    ) {
        let status: u8 = market_status.get_or_use(market_id, VOID);
        assert_eq(status, reported_status);
        assert_eq(status == RESOLVED || status == VOID, true);
        let position: PositionKey = PositionKey {
            market_id,
            bettor: caller,
            side_yes
        };
        let already_claimed: bool = position_claimed.get_or_use(position, false);
        assert_eq(already_claimed, false);
        let onchain_user_amount: u64 = position_amount.get_or_use(position, 0u64);
        assert_eq(onchain_user_amount, reported_user_amount);

        let onchain_yes_total: u64 = yes_total_public.get_or_use(market_id, 0u64);
        let onchain_no_total: u64 = no_total_public.get_or_use(market_id, 0u64);
        assert_eq(onchain_yes_total, reported_yes_total);
        assert_eq(onchain_no_total, reported_no_total);

        if status == RESOLVED {
            let onchain_outcome_yes: bool = outcome_yes.get(market_id);
            assert_eq(onchain_outcome_yes, reported_outcome_yes);
        }
        position_claimed.set(position, true);
    }
}
